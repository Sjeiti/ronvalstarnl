{
  "id": 3328,
  "date": "2017-08-02T08:59:52",
  "date_gmt": "2017-08-02T08:59:52",
  "guid": {
    "rendered": "http://ronvalstar.nl/?p=3328"
  },
  "modified": "2017-09-27T05:39:51",
  "modified_gmt": "2017-09-27T05:39:51",
  "slug": "experiment-marbles",
  "status": "publish",
  "type": "post",
  "link": "https://ronvalstar.nl/experiment-marbles",
  "title": {
    "rendered": "Experiment: marbles"
  },
  "content": {
    "rendered": "<p>Last week I saw an old image in my library of <a href=\"http://test.sjeiti.com/knikkeren/\">something I created</a> back in 2006. It was a few marbles created using Flash and displacement mapping. Remember BitmapData and DisplacementMapFilter? No I didn&#8217;t either.<br />\nBut since I&#8217;m learning GLSL I thought this would be an excellent little experiment to recreate.<br />\n<!--more--><br />\nBack then I did the physics myself but this time I wanted to concentrate on the WebGL part so I used Matter.js. Circles in Matter are really just a polygon of vertices, but it works just fine.<br />\nSo the physics part is plain Javascript, the view is all GLSL.</p>\n<h2>Some goals</h2>\n<p>I was going for looks, not creating anatomically correct glass and refraction. So the what you see is not 3D. If you nitpick there are all sorts of things that are off like the rotation of the marbles or the refraction over the hole. But overal it looks good.</p>\n<p>What I wanted to learn from this experiment is:<br />\n&#8211; more displacement mapping<br />\n&#8211; realistic marble colors<br />\n&#8211; object lighting<br />\n&#8211; Javascript lists to uniforms</p>\n<p>What I also learned was:<br />\n&#8211; passing a list of structs from Javascript to the shader<br />\n&#8211; passing uniform data can be faster than using prng in GLSL<br />\n&#8211; GLSL operations order<br />\n&#8211; environment mapping</p>\n<h2>Getting started</h2>\n<p>I&#8217;m going to skip the setup because there are enough <a href=\"https://www.google.com/search?q=WebGL+boilerplate\">WebGL boilerplates</a> out there for you to get started with. Or you could fiddle around on <a href=\"http://shadertoy.com\">ShaderToy</a>.<br />\nI do want to point out that in most implementations you will see that the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext\">WebGL2RenderingContext</a> derived from <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement\">HTMLCanvasElement</a> is simply called <code>gl</code>. So when you see <code>gl</code> it&#8217;s really the context from <code>canvas.getContext()</code>.</p>\n<h2>Javascript arrays to GLSL uniforms</h2>\n<p>The crux of the experiment was really getting a list of Javascript data (marble positions) into the GLSL shader. There are sixteen methods you can use depending on the data.<br />\nThat might sound overwelming but it&#8217;s simply like this:</p>\n<pre><code>gl.uniform[1234][fi][v]()</code></pre>\n<p>The digits are the number of variables to pass (float, vec2, vec3, vec4 etc&#8230;).<br />\nFollowed by the type: Floats or Integers.<br />\nAnd an optional v passing the vector as array.</p>\n<p>So for a plain Javascript number you&#8217;d use <code>gl.uniform1f()</code> to pass it to a <code>uniform float</code>.<br />\nFor an array of marble positions you&#8217;d use <code>gl.uniform2fv()</code> to pass it to a <code>uniform vec2 myPositions[23]</code>.</p>\n<p><small>Here you can immediately see a property of GLSL that is a bit tricky to deal with: the array length must always be of type <code>const int</code>, but a <code>uniform</code> cannot be <code>const</code>. So the array length must fixed.<br />\nThere are tricks to overcome this if you need the freedom. One is to set the length to a maximum in GLSL and only calculate when properties are set.<br />\nThis is what I did at first: used <code>gl.uniform3fv()</code> to pass a <code>vec3</code> for marble x, y, radius. In the GLSL loop I&#8217;d first check for <code>marbleRadius!=0.0</code>.<br />\nSo in Javascript your array would count 10 but in GLSL it would be 20.</small></p>\n<p>To use the <code>gl.uniform[1234][fi][v]()</code> method we first need to get the location:</p>\n<pre><code>let uniformLocation = gl.getUniformLocation(program,'myFloat')\r\ngl.uniform1f(uniformLocation,2.3)</code></pre>\n<p>Passing an array is slightly different. An array of vec2:</p>\n<pre><code>let uniformLocation\r\nuniformLocation = gl.getUniformLocation(program,'myPos[0]')\r\ngl.uniform2f(uniformLocation,2.3,4.5)\r\nuniformLocation = gl.getUniformLocation(program,'myPos[1]')\r\ngl.uniform2f(uniformLocation,3.4,5.6)</code></pre>\n<p>And an example using the [v] variant (same effect as above):</p>\n<pre><code>let uniformLocation\r\nuniformLocation = gl.getUniformLocation(program,'myPos[0]')\r\ngl.uniform2fv(uniformLocation,[2.3,4.5])\r\nuniformLocation = gl.getUniformLocation(program,'myPos[1]')\r\ngl.uniform2fv(uniformLocation,[3.4,5.6])</code></pre>\n<p><small>By the way, <code>program</code> here refers to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\">WebGLProgram</a>, the return from <code>gl.createProgram()</code>. This is your vertex- and fragment shader combined.</small></p>\n<h2>Onto colored marbles</h2>\n<p>What I first did was pass a Javascript Array to the shader as <code>vec3</code> where <code>vec3.z</code> would be the radius of the marble. I used the index of the array as the seed for a prng to get six floats for two rgb colors. This works but it&#8217;s not very efficient. Because when <code>gl_FragCoord.xy</code> is within radius of the marble it will have to get the two colors for each pixel. To put in perspective: for a marble with a 20 pixel radius we&#8217;d have to call the prng about 7500 times (PI*r&sup2;*6).</p>\n<h2>What the struct?!</h2>\n<p>While searching on how to get Javascript arrays to GLSL uniforms I also came upon a solution to pass Javascript objects to an array of GLSL <a href=\"https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Structs\">structs</a>. After reading up on structs (which are like a blueprint collection of properties, like an interface) I decided this was better suited for what I was doing. After implementing and ditching the prng it was indeed way faster.</p>\n<p>In GLSL a struct for the marbles could look like this:</p>\n<pre><code>const int numMarbles = 16;\r\nstruct Marble {\r\n    vec2 position;\r\n    float size;\r\n    vec3 color1;\r\n    vec3 color2;\r\n};\r\nuniform Marble marbles[numMarbles];</code></pre>\n<p>And passing the data from Javascript to GLSL is similar to the stringifying of the array index, you&#8217;d also stringify the property name:</p>\n<pre><code>let uniformLocation\r\nuniformLocation = gl.getUniformLocation(program,'marbles[0].position')\r\ngl.uniform2fv(uniformLocation,[position.x,position.y])\r\nuniformLocation = gl.getUniformLocation(program,'marbles[0].size')\r\ngl.uniform1f(uniformLocation,20)\r\nuniformLocation = gl.getUniformLocation(program,'marbles[0].color1')\r\ngl.uniform3fv(uniformLocation,[color1.r,color1.g,color1.b])\r\nuniformLocation = gl.getUniformLocation(program,'marbles[0].color2')\r\ngl.uniform3fv(uniformLocation,[color2.r,color2.g,color2.b])</code></pre>\n<p>Yeah this looks convoluted, but it&#8217;s for shows. I&#8217;m sure you can manage something more generic.</p>\n<h2>Swirls and rotation</h2>\n<p>Like I said; this is not 3D. But I did want stuff to roll around somewhat realisticly. And marbles have these colorfull swirls. So in the end what I&#8217;ve settled for is rotation depending on horizontal direction.</p>\n<pre line-numbers><code data-language=\"glsl\" data-src=\"/static/glsl/marbles.glsl\"></code></pre>\n<pre line-numbers><code data-language=\"javascript\" data-src=\"/static/experiment/marbles.js\"></code></pre>\n",
    "protected": false
  },
  "excerpt": {
    "rendered": "<p>Last week I saw an old image in my library of something I created back in 2006. It was a few marbles created using Flash and displacement mapping. Remember BitmapData and DisplacementMapFilter? No I didn&#8217;t either. But since I&#8217;m learning GLSL I thought this would be an excellent little experiment to recreate.</p>\n",
    "protected": false
  },
  "author": 2,
  "featured_media": 0,
  "comment_status": "open",
  "ping_status": "open",
  "sticky": false,
  "template": "",
  "format": "standard",
  "meta": [],
  "categories": [
    5,
    9,
    13,
    26
  ],
  "tags": [
    284,
    297,
    314
  ],
  "terms": {
    "post_tag": [
      {
        "term_id": 284,
        "name": "3D",
        "slug": "3d",
        "term_group": 0,
        "term_taxonomy_id": 30,
        "taxonomy": "post_tag",
        "description": "",
        "parent": 0,
        "count": 9,
        "filter": "raw",
        "term_order": "0",
        "ID": 284
      },
      {
        "term_id": 297,
        "name": "webgl",
        "slug": "webgl",
        "term_group": 0,
        "term_taxonomy_id": 301,
        "taxonomy": "post_tag",
        "description": "",
        "parent": 0,
        "count": 6,
        "filter": "raw",
        "term_order": "0",
        "ID": 297
      },
      {
        "term_id": 314,
        "name": "physics",
        "slug": "physics",
        "term_group": 0,
        "term_taxonomy_id": 318,
        "taxonomy": "post_tag",
        "description": "",
        "parent": 0,
        "count": 1,
        "filter": "raw",
        "term_order": "0",
        "ID": 314
      }
    ],
    "category": [
      {
        "term_id": 5,
        "name": "code",
        "slug": "code",
        "term_group": 0,
        "term_taxonomy_id": 5,
        "taxonomy": "category",
        "description": "",
        "parent": 170,
        "count": 71,
        "filter": "raw",
        "term_order": "0",
        "ID": 5
      },
      {
        "term_id": 9,
        "name": "game",
        "slug": "game",
        "term_group": 0,
        "term_taxonomy_id": 9,
        "taxonomy": "category",
        "description": "",
        "parent": 26,
        "count": 8,
        "filter": "raw",
        "term_order": "0",
        "ID": 9
      },
      {
        "term_id": 13,
        "name": "Javascript",
        "slug": "javascript",
        "term_group": 0,
        "term_taxonomy_id": 13,
        "taxonomy": "category",
        "description": "",
        "parent": 5,
        "count": 52,
        "filter": "raw",
        "term_order": "0",
        "ID": 13
      },
      {
        "term_id": 26,
        "name": "work",
        "slug": "work",
        "term_group": 0,
        "term_taxonomy_id": 26,
        "taxonomy": "category",
        "description": "",
        "parent": 0,
        "count": 16,
        "filter": "raw",
        "term_order": "0",
        "ID": 26
      }
    ]
  },
  "_links": {
    "self": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/posts/3328"
      }
    ],
    "collection": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/posts"
      }
    ],
    "about": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/types/post"
      }
    ],
    "author": [
      {
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/users/2"
      }
    ],
    "replies": [
      {
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/comments?post=3328"
      }
    ],
    "version-history": [
      {
        "count": 9,
        "href": "https://ronvalstar.nl/api/wp/v2/posts/3328/revisions"
      }
    ],
    "predecessor-version": [
      {
        "id": 3354,
        "href": "https://ronvalstar.nl/api/wp/v2/posts/3328/revisions/3354"
      }
    ],
    "wp:attachment": [
      {
        "href": "https://ronvalstar.nl/api/wp/v2/media?parent=3328"
      }
    ],
    "wp:term": [
      {
        "taxonomy": "category",
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/categories?post=3328"
      },
      {
        "taxonomy": "post_tag",
        "embeddable": true,
        "href": "https://ronvalstar.nl/api/wp/v2/tags?post=3328"
      }
    ],
    "curies": [
      {
        "name": "wp",
        "href": "https://api.w.org/{rel}",
        "templated": true
      }
    ]
  }
}