{"id":"1775","description":"Creating proper tileable noise maps is a bit tricky to get your head around if you want to do it right. Here's how to do it step by step.","date":"2012-09-26T11:11:32","modified":"2015-12-24T19:58:21","slug":"creating-tileable-noise-maps","type":"post","categories":["code"],"tags":["Perlin Noise","simplex noise","tile","pattern","dimension","cool shit"],"metaKeyword":"tileable noise","metaTitle":"Creating tileable noise maps","metaDescription":"Creating proper tileable noise maps is a bit tricky to get your head around if you want to do it right. Here's how to do it step by step.","inCv":false,"inPortfolio":false,"dateFrom":"","dateTo":"","title":"Creating tileable noise maps","content":"<p>Creating a tileable image in Photoshop is easy; crop an image, take the cropped right and bottom and stick it left and top with a fade. But creating proper tileable noise maps is a bit trickier to get your head around if you want to do it right.</p>\n<p><!--more--></p>\n<p>If you have a <a title=\"Hugo Elias on Perlin noise\" href=\"http://freespace.virgin.net/hugo.elias/models/m_perlin.htm\" target=\"_blank\">basic understanding of Perlin noise</a> you&#8217;ll know that it consists of interpolated random numbers. People mostly use it in two dimensions. But it&#8217;s also useful in one dimension (movement for instance), in three dimensions (cylindrical and spherical mapping of 3D objects) and even four or five dimensions.<br />\nYou can use four dimensional noise to create a tileable 2D image. Thinking in four dimensions is not an everday practice so we&#8217;ll take it one dimension at a time.</p>\n<p>In <a href=\"http://test.ronvalstar.nl/noiseTiling\">the examples</a> I&#8217;ve used <a title=\"Simplex noise on Wikipedia\" href=\"http://en.wikipedia.org/wiki/Simplex_noise\" target=\"_blank\">Simplex noise</a> with two octaves. Simplex noise is faster in higher dimensions and it looks better because of it&#8217;s triangular nature.<br />\nI&#8217;ve written a small function called drawNoise to deal with canvas creation and pixel array looping. You can <a href=\"/wordpress/wp-content/uploads/noiseTiling.zip\">download the examples here</a>.</p>\n<h2>One dimensional tileable noise</h2>\n<p>In one dimension the noise is an endless smooth line (my noise implementation starts at two so I&#8217;m using a constant for the second parameter). Here you can still really see it&#8217;s just interpolated random numbers.</p>\n<pre><code data-language=\"javascript\" data-line=\"128\">// one dimensional line\nfNoiseScale = .02;\ndrawNoise(function(i,x,y){\n\tvar v = Simplex.noise(\n\t\t 123+x*fNoiseScale\n\t\t,137 // we just need one dimension so this parameter is a constant\n\t);\n\treturn v*iSize&gt;y?255:0;\n}).img();</code></pre>\n<p><img src=\"/wordpress/wp-content/uploads/line.jpg\" alt=\"one dimensional noise\" /></p>\n<p>You can use this in your animation by recalculation the noise value for each millisecond but you could also create a loop and precalculate the values. The values in the image above do not loop. But looping is quite easy, all it takes is an extra dimension and a loop&#8230; or eeh circle.</p>\n<h2>A one dimensional loop</h2>\n<p>For most of you Perlin noise looks something like the following image.</p>\n<p><img src=\"/wordpress/wp-content/uploads/noise.jpg\" alt=\"Simplex noise\" /></p>\n<p>If we were to draw a circle in there and read out the noise values on that circle we&#8217;d have a one dimensional loop.</p>\n<p><img src=\"/wordpress/wp-content/uploads/noiseCircle.jpg\" alt=\"Noise with a circle to create a one dimensional loop\" /></p>\n<p>In code this looks like this:</p>\n<pre><code data-language=\"javascript\" data-line=\"162\">// one dimensional loop\ndrawNoise(function(i,x,y){\n\tvar fNX = x/iSize // we let the x-offset define the circle\n\t\t,fRdx = fNX*2*Math.PI // a full circle is two pi radians\n\t\t,a = fRdsSin*Math.sin(fRdx)\n\t\t,b = fRdsSin*Math.cos(fRdx)\n\t\t,v = Simplex.noise(\n\t\t\t 123+a*fNoiseScale\n\t\t\t,132+b*fNoiseScale\n\t\t)\n\t;\n\treturn v*iSize&gt;y?255:0;\n}).img().div(2);</code></pre>\n<div style=\"background: url('/wordpress/wp-content/uploads/lineLoop.jpg'); height: 128px;\"></div>\n<p>&nbsp;</p>\n<p>You can probably already see where we are going with this. For looping a two dimensional image we&#8217;ll need a three dimensional noise map (at least).</p>\n<h2>A cylindrical map</h2>\n<p>Perlin noise was originally created for continuous 3D texturing (Tron). Instead of the image map being a piece of paper wrapped around an object the image map is calculated by the location in the three dimensional noise field. So when slicing the object you&#8217;d still be able to calculate the map for the newly created surface.</p>\n<p>Before our ultimate goal of a tileable image we will first create one that just tiles left and right. It&#8217;s like the two dimensional circle for our one dimensional loop but with one extra dimension: a cylinder.</p>\n<pre><code data-language=\"javascript\" data-line=\"178\">// three dimensional cylindrical map\ndrawNoise(function(i,x,y){\n\tvar fNX = x/iSize\n\t\t,fRdx = fNX*2*Math.PI\n\t\t,a = fRdsSin*Math.sin(fRdx)\n\t\t,b = fRdsSin*Math.cos(fRdx)\n\t\t,v = Simplex.noise(\n\t\t\t 123+a*fNoiseScale\n\t\t\t,132+b*fNoiseScale\n\t\t\t,312+y*fNoiseScale // similar to the one dimensional loop but we add a third dimension defined by the image y-offset\n\t\t)\n\t;\n\treturn v*255&lt;&lt;0;\n}).img().div(2);</code></pre>\n<p><img src=\"/wordpress/wp-content/uploads/noiseCylindrical.jpg\" alt=\"a cylindrical noise map\" /></p>\n<h2>A spherical image map</h2>\n<p>You might think a sphere would come in handy for our tileable image but you&#8217;re wrong.<br />\nAs a small sidestep I&#8217;ll show you how to calculate a spherical image map and what it looks like.</p>\n<pre><code data-language=\"javascript\" data-line=\"195\">// three dimensional spherical map\ndocument.body.addChild('h2').innerText = 'three dimensional spherical map';\nfNoiseScale = .1;\nvar oSpherical = drawNoise(function(i,x,y){\n\tvar  fNX = (x+.5)/iSize // added half a pixel to get the center of the pixel instead of the top-left\n\t\t,fNY = (y+.5)/iSize\n\t\t,fRdx = fNX*2*Math.PI\n\t\t,fRdy = fNY*Math.PI // the vertical offset of a 3D sphere spans only half a circle, so that is one Pi radians\n\t\t,fYSin = Math.sin(fRdy+Math.PI) // a 3D sphere can be seen as a bunch of cicles stacked onto each other, the radius of each of these is defined by the vertical position (again one Pi radians)\n\t\t,a = fRdsSin*Math.sin(fRdx)*fYSin\n\t\t,b = fRdsSin*Math.cos(fRdx)*fYSin\n\t\t,c = fRdsSin*Math.cos(fRdy)\n\t\t,v = Simplex.noise(\n\t\t\t 123+a*fNoiseScale\n\t\t\t,132+b*fNoiseScale\n\t\t\t,312+c*fNoiseScale\n\t\t)\n\t;\n\treturn v*255&lt;&lt;0;\n}).img();</code></pre>\n<p><img src=\"/wordpress/wp-content/uploads/noiseSpherical.jpg\" alt=\"a spherical noise map\" /><img src=\"/wordpress/wp-content/uploads/sphere.jpg\" alt=\"a sphere with noise\" /></p>\n<h2>Cubical panorama map</h2>\n<p>The sphere we just made can also be used as a panorama if we&#8217;d put the camera in the center of the sphere. But a better technique is a cubical panorama because it has far less faces. The sphere is mapped onto the six sides of a cube as indicated by this sketch.</p>\n<p><img src=\"/wordpress/wp-content/uploads/sketchCube.jpg\" alt=\"sketch mapping sphere to cube\" /></p>\n<p>For each pixel on the face of the cube we have to calculate the intersection between our viewpoint C in the center and the sphere. This might sound difficult but really isn&#8217;t.</p>\n<p>We can perceive the line CA as a vector. And vectors can be normalized, so it&#8217;s direction doesn&#8217;t change but it&#8217;s length is reduced to 1. Which makes all our vectors together look like a sphere.</p>\n<p>Normalization is also quite simple, we just have to divide the xyz values of the vector with the total length of the vector. The length of the vector can be calculated using the theorem or Pythagoras.</p>\n<p>In the code below you can see the normalize calculation is first done for a single face. Then the noise is calculated for al six faces simultaneously since its just a matter of swapping xyz values to get the position on another face.</p>\n<pre><code data-language=\"javascript\" data-line=\"238\">// 3D panoramical cube map\ndocument.body.addChild('h2').innerText = '3D panoramical cube map';\n// we're not using the drawNoise function because our canvas is rectangular\nvar mCubemap = document.createElement('canvas')\n\t,iW = 6*iSize;\nmCubemap.width = iW;\nmCubemap.height = iSize;\nvar  iHSize = iSize/2 // half the size of the cube\n\t,oCtx = mCubemap.getContext('2d')\n\t,oImgData = oCtx.getImageData(0,0,iW,iSize)\n\t,aPixels = oImgData.data\n\t,aa = 123\n\t,bb = 231\n\t,cc = 321\n;\nfor (var i=0,l=iSize*iSize;i&lt;l;i++) {\n\tvar  x = i%iSize\t\t// x position in image\n\t\t,y = (i/iSize)&lt;&lt;0\t// y position in image\n\t\t,a = -iHSize + x+.5\t// x position on the cube plane, the added .5 is to get the center of the pixel\n\t\t,b = -iHSize + y+.5 // y position on the cube plane\n\t\t,c = -iHSize\t\t// z position of the cube plane\n\t\t,fDistanceAB = Math.sqrt(a*a+b*b) // to calculate the vectors length we use Pythagoras twice\n\t\t,fDistanceABC = Math.sqrt(fDistanceAB*fDistanceAB+c*c)\n\t\t,fDrds = .5*fDistanceABC // adjust the distance a bit to get a better radius in the noise field\n\t\t,v = 1\n\t;\n\ta /= fDrds; // normalize the vector\n\tb /= fDrds; // normalize the vector\n\tc /= fDrds; // normalize the vector\n\t//\n\t// since we now know the spherical position for one plane we can derive the positions for the other five planes simply by switching the x, y and z values (the a, b and c variables)\n\tvar aNoisePositions = [\n\t\t [a,b,c]\t// back\n\t\t,[-c,b,a]\t// right\n\t\t,[-a,b,-c]\t// front\n\t\t,[c,b,-a]\t// left\n\t\t,[a,c,-b]\t// top\n\t\t,[a,-c,b]\t// bottom\n\t];\n\tfor (var j=0;j&lt;6;j++) {\n\t\tv = Simplex.noise(\n\t\t\t aa + aNoisePositions[j][0]\n\t\t\t,bb + aNoisePositions[j][1]\n\t\t\t,cc + aNoisePositions[j][2]\n\t\t);\n\t\tvar pos = 4*(y*iW+j*iSize+x); // the final position of the rgba pixel\n\t\taPixels[pos] = aPixels[pos+1] = aPixels[pos+2] = v*255&lt;&lt;0;\n\t\taPixels[pos+3] = 255;\n\t}\n}\noCtx.putImageData(oImgData,0,0);\ndocument.body.addChild('img',{src:mCubemap.toDataURL(\"image/jpeg\")});</code></pre>\n<p>Here are the six sides stuck into a single image plus a screenshot of what it looks like from within the cube. The source code also has an actual 3D example done with <a title=\"mr Doob's threejs on Github\" href=\"https://github.com/mrdoob/three.js/\" target=\"_blank\">threejs</a>.</p>\n<p><img src=\"/wordpress/wp-content/uploads/noiseCubeMap.jpg\" alt=\"cubical panorama map\" /></p>\n<p><img src=\"/wordpress/wp-content/uploads/noiseCubeMap3D1.jpg\" alt=\"noiseCubeMap3D\" /></p>\n<h2>A 2D tileable image</h2>\n<p>A 2D tileable image might seem easy but I find it the most difficult of the ones I described here because understanding it requires you to think in four dimensions. The closest we really got was the cylindrical map (with it&#8217;s horizontal repeat), so we&#8217;ll take that as our starting point.<br />\nIn the cylindrical map we used the image horizontal position for the circle; so the horizontal image position provided us with two coordinates x and y in the noise xyz field. The image&#8217;s vertical position corresponded to z in the noise field.</p>\n<p>We also want the image to tile vertically so if we add an extra dimension we can use it to create a second circle to replace the fields linear z value. It&#8217;s almost like creating two cylinders in a four dimensional field. I tried to vizualize it a bit in the following sketch, it&#8217;s not accurate but I&#8217;m trying to convey the general idea, not draw a four dimensional cylinder.</p>\n<p><img src=\"/wordpress/wp-content/uploads/sketchCylinders.jpg\" alt=\"sketch of two cylinders in four dimensions\" /></p>\n<p>The code pretty straightforward; just two circles in four dimensional noise space.</p>\n<pre><code data-language=\"javascript\" data-line=\"343\">// four dimensional tile\nfNoiseScale = .003;\ndrawNoise(function(i,x,y){\n\tvar  fNX = x/iSize\n\t\t,fNY = y/iSize\n\t\t,fRdx = fNX*2*Math.PI\n\t\t,fRdy = fNY*2*Math.PI\n\t\t,a = fRds*Math.sin(fRdx)\n\t\t,b = fRds*Math.cos(fRdx)\n\t\t,c = fRds*Math.sin(fRdy)\n\t\t,d = fRds*Math.cos(fRdy)\n\t\t,v = Simplex.noise(\n\t\t\t 123+a*fNoiseScale\n\t\t\t,231+b*fNoiseScale\n\t\t\t,312+c*fNoiseScale\n\t\t\t,273+d*fNoiseScale\n\t\t)\n\t;\n\treturn (Math.min(Math.max(2*(v -.5)+.5,0),1)*255)&lt;&lt;0;\n}).img().div(2,2);</code></pre>\n<p>And here&#8217;s the result:</p>\n<div style=\"background: url('/wordpress/wp-content/uploads/noiseTileable.jpg'); height: 400px;\"></div>"}